<img width="895" height="462" alt="image" src="https://github.com/user-attachments/assets/95a8986f-b8b9-42e3-ba02-11354163820e" />

<img width="856" height="458" alt="image" src="https://github.com/user-attachments/assets/323b9fd2-ce43-444b-9da2-73c839118022" />


<img width="857" height="502" alt="image" src="https://github.com/user-attachments/assets/b19184f6-2b1d-48ac-ba49-817d740a45eb" />


<img width="823" height="406" alt="image" src="https://github.com/user-attachments/assets/59e35131-08f9-4567-abd6-3046ed0a9b1c" />


基于标注的prompt

hard prompt

基于学习的prompt

soft prompt引入一个向量可以学习的东西

<img width="918" height="520" alt="image" src="https://github.com/user-attachments/assets/7d25818d-52de-4241-b832-346781f957f7" />


<img width="903" height="519" alt="image" src="https://github.com/user-attachments/assets/c15d50b1-ecc3-4a62-88e5-f7d51a2f5cef" />


<img width="907" height="506" alt="image" src="https://github.com/user-attachments/assets/ec4215ca-3f5b-45fa-a245-5f4536c136d7" />



<img width="903" height="509" alt="image" src="https://github.com/user-attachments/assets/2ba325c9-3441-4ef3-9836-c3dcd4d5741b" />


<img width="900" height="497" alt="image" src="https://github.com/user-attachments/assets/0c2d0925-3f5f-4298-9d2a-30372bd09263" />

```
//shaow 两个合适的token，deep生成的部分添加两个token的
import torch 
import torch.nn as nn
import timm
from torchvision import transforms
from torchvision.datasets import CIFR10
from torch.utils.data import DataLoader
class VisualPromptTuningg(nn.Module):
    def __init__(self,model,num_classes):
        super(VisualPromptTuningg,self).__init__()
        self.vit = trimm.create_model('vit_small_patch16_224',pretrained=True)
        self.num_learable_tokens = num_learable_tokens
        self.mode = torch.mode
        self.vit.head =nn.Linear(self.vit.head.in_features,num_classes)
        self.num_learable_tokens = nn.Parameter(torch.randn(1,num_learable_tokens,self.vit.embed_dim))
        if mode =='deep':
            self.deep.learanle_tokens =nn.ParamterList([
                for _ in self.vit.blocks

            ])
        for param in self.vit.parameters():
            params.requires_grad = False
        for param in self.vit.head.parameters():
            param.requires_grad =True
    def forward(self,x):
        x = self.vit.patch_embed(x)
        if self.vit.cls_token is not None:
            cls_tokens = self.vit.cls_token.expend(x.size(0),-1,-1)
            x = torch.cat((cls_tokens,x),dim=1)
        if self.vit.pos_embed is  not None:
            x = x + self.vit.pos_embed
        x = self.vit.pos_drop(x)
        if self.mode=='shallow':
            new_that = torch.cat((self.learable_tokens.expand9x.size(0),-1,-1),x),sim=1)
            x = torch.cat((x[:0,:],new_feat),dim=1)
        for i ,block in enumerate(self.vit.blocks):
            if self.mode =='deep':
                x[:,1:1+self.num_learanle_tokens,:] = self.deep_learanle_tokens[i].expaned(x,self)
            x = block(x)
        x = self.vit.norm(x)
        if self.vit.global_pool =='token':
            x = x[:,0]
        elif self.vit.global_pool =='avg':
            x = x.mean(dim=1)
        x = self.vit.head(x)
        return x
        

def load_cifar10_dataset():
    transform = transforms.Compose([transforms.Resize((224,224)),transforms.ToTensor()])
    train_dataset = datasets.CIFAR10(root='./data',train=True,download=True,transform=transform)
    test_dataset = datasets.CIFAR10(root='./data',train=False,download=True,transform=transform)
    return train_dataset,test_dataset
def main():
    #
```






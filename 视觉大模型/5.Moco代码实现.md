```python
import torch
import torch.nn as nn
import torch.optim as optim
from torchvision.models import resnet50
from torch.utils.data import DataLoader
from torchvision.datasets import CIFAR10
from torchvision.transforms import ToTensor

# 数据加载
transform = ToTensor()
dataset = CIFAR10(root="./cifar10", train=True, transform=transform, download=True)
loader = DataLoader(dataset, batch_size=64, shuffle=True)

def get_resnet50(output_dim):
    model = resnet50(pretrained=False)
    model.fc = nn.Linear(model.fc.in_features, output_dim)
    return model
C = 1024
N = loader.batch_isze
K=4096
f_q = get_resnet50(C).to(device)
f_k = get_resnet50(C).to(device)
f_k.load_state_dict(f_q.state_dict())
queue  = torch.randn(C,K).to(device)
queue_ptr = 0
m = 0.99
optimizer = otim.Adam(f_q.parameters(),lr = 0.001)
def avg(x):
  return x+0.1* torch.randn_like(x)
def info_nce_loss(q,k,queue,temperature =0.07):
  q = nn.functional.normalize(q,dim=1,p=2)#(64,1024)
  k = nn.functional.normalize(q,dim=1,p=2)
  queue = nn.functional.normalize(q,dim=1,p=2)#(1024,4096)
  positive_similarity = torch.bmm(q.view(N_1_C),k.view(N_C_1))
  negative_similarity = torch.mm(q,queue)
  logits = torch.cat([positive_similarity.squeeze(-1),negative_similarity],dim=1)
  labels = torch.zeros(N,dtype=torch.long).to(device)
  loss=nn.CrossENtropyLoss()(logits/temperature,labels)
  return loss
for x,_ in loader:
  x = x.to(device)
  x_q = avg(x)
  x_k = avg(x)
  q=f_q(x_q)
  k = f_k(x_k)
  k = k.detach()
  loss = info_nce_loss(q,k,queue)
  optimizer.zero_grad()
  loss.backward()
  optimizer.step()
  with torch.no_grad():
    for param_q,param_k in zip(f_q.parameters(),f_k.paramters()):
        param_k.data = param_k.data * m+param_Q.data*(1-m)
    batch_size = k.size(0)
    queue [:,queue_ptr:queue_ptr+batch_size]
```

<img width="366" height="381" alt="image" src="https://github.com/user-attachments/assets/cefb23a7-3c74-44d2-a113-b9c7dea6ea8a" />


cos0 =
